{"meta":{"title":"非鱼博客","subtitle":"非鱼博客小站","description":"","author":"funing.ma","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"5.MySQL - 优化（重点掌握）","date":"2022-06-17T02:57:09.648Z","updated":"2022-05-18T07:51:38.501Z","comments":true,"path":"2022/06/17/5.MySQL - 优化（重点掌握）/","link":"","permalink":"http://example.com/2022/06/17/5.MySQL%20-%20%E4%BC%98%E5%8C%96%EF%BC%88%E9%87%8D%E7%82%B9%E6%8E%8C%E6%8F%A1%EF%BC%89/","excerpt":"","text":"概述 表关联查询时务必遵循 小表驱动大表 原则； 使用查询语句 where 条件时，不允许出现 函数，否则索引会失效； 使用单表查询时，相同字段尽量不要用 OR，因为可能导致索引失效，比如：SELECT * FROM table WHERE name = &#39;手机&#39; OR name = &#39;电脑&#39;，可以使用 UNION 替代； LIKE 语句不允许使用 % 开头，否则索引会失效； 组合索引一定要遵循 从左到右 原则，否则索引会失效；比如：SELECT * FROM table WHERE name = &#39;张三&#39; AND age = 18，那么该组合索引必须是 name,age 形式； 索引不宜过多，根据实际情况决定，尽量不要超过 10 个； 每张表都必须有 主键，达到加快查询效率的目的； 分表，可根据业务字段尾数中的个位或十位或百位（以此类推）做表名达到分表的目的； 分库，可根据业务字段尾数中的个位或十位或百位（以此类推）做库名达到分库的目的； 表分区，类似于硬盘分区，可以将某个时间段的数据放在分区里，加快查询速度，可以配合 分表 + 表分区 结合使用； 神器 EXPLAIN 语句EXPLAIN 显示了 MySQL 如何使用索引来处理 SELECT 语句以及连接表。可以帮助选择更好的索引和写出更优化的查询语句。 使用方法，在 SELECT 语句前加上 EXPLAIN 即可，如： 1EXPLAIN SELECT * FROM tb_item WHERE cid IN (SELECT id FROM tb_item_cat) id： SELECT 识别符。这是 SELECT 的查询序列号 select_type： SELECT类型,可以为以下任何一种 SIMPLE: 简单 SELECT(不使用 UNION 或子查询) PRIMARY: 最外面的 SELECT UNION: UNION 中的第二个或后面的 SELECT 语句 DEPENDENT UNION: UNION 中的第二个或后面的 SELECT 语句,取决于外面的查询 UNION RESULT: UNION 的结果 SUBQUERY: 子查询中的第一个 SELECT DEPENDENT SUBQUERY: 子查询中的第一个 SELECT,取决于外面的查询 DERIVED: 导出表的 SELECT(FROM 子句的子查询) table： 输出的行所引用的表 partitions： 表分区 type： 联接类型。下面给出各种联接类型，按照 从最佳类型到最坏类型 进行排序 system: 表仅有一行(&#x3D;系统表)。这是 const 联接类型的一个特例。 const: 表最多有一个匹配行,它将在查询开始时被读取。因为仅有一行,在这行的列值可被优化器剩余部分认为是常数。const 表很快,因为它们只读取一次! eq_ref: 对于每个来自于前面的表的行组合, 从该表中读取一行。这可能是最好的联接类型, 除了 const 类型。 ref: 对于每个来自于前面的表的行组合, 所有有匹配索引值的行将从这张表中读取。 ref_or_null: 该联接类型如同 ref,但是添加了 MySQL 可以专门搜索包含 NULL 值的行。 index_merge: 该联接类型表示使用了索引合并优化方法。 unique_subquery: 该类型替换了下面形式的 IN 子查询的 ref: value IN (SELECT primary_key FROM single_table WHERE some_expr) unique_subquery 是一个索引查找函数, 可以完全替换子查询, 效率更高。 index_subquery: 该联接类型类似于 unique_subquery。可以替换 IN 子查询, 但只适合下列形式的子查询中的非唯一索引: value IN (SELECT key_column FROM single_table WHERE some_expr) range: 只检索给定范围的行,使用一个索引来选择行。 index: 该联接类型与 ALL 相同,除了只有索引树被扫描。这通常比 ALL 快,因为索引文件通常比数据文件小。 ALL: 对于每个来自于先前的表的行组合, 进行完整的表扫描。 possible_keys： 指出 MySQL 能使用哪个索引在该表中找到行 key： 显示 MySQL 实际决定使用的键(索引)。如果没有选择索引, 键是 NULL。 key_len： 显示 MySQL 决定使用的键长度。如果键是 NULL, 则长度为 NULL。 ref： 显示使用哪个列或常数与 key 一起从表中选择行。 rows： 显示 MySQL 认为它执行查询时必须检查的行数。多行之间的数据相乘可以估算要处理的行数。 filtered： 显示了通过条件过滤出的行数的百分比估计值。 Extra： 该列包含 MySQL 解决查询的详细信息 Distinct: MySQL 发现第 1 个匹配行后,停止为当前的行组合搜索更多的行。 Not exists: MySQL 能够对查询进行 LEFT JOIN 优化, 发现 1 个匹配 LEFT JOIN 标准的行后, 不再为前面的的行组合在该表内检查更多的行。 range checked for each record (index map: #): MySQL 没有发现好的可以使用的索引, 但发现如果来自前面的表的列值已知, 可能部分索引可以使用。 Using filesort: MySQL 需要额外的一次传递, 以找出如何按排序顺序检索行。 Using index: 从只使用索引树中的信息而不需要进一步搜索读取实际的行来检索表中的列信息。 Using temporary: 为了解决查询, MySQL 需要创建一个临时表来容纳结果。 Using where: WHERE 子句用于限制哪一个行匹配下一个表或发送到客户。 Using sort_union(…), Using union(…), Using intersect(…): 这些函数说明如何为 index_merge 联接类型合并索引扫描。 Using index for group-by: 类似于访问表的 Using index 方式,Using index for group-by 表示 MySQL 发现了一个索引,可以用来查询 GROUP BY 或 DISTINCT 查询的所有列, 而不要额外搜索硬盘访问实际的表。","categories":[],"tags":[]},{"title":"","slug":"4.Zookeeper - 假死脑裂","date":"2022-06-17T02:57:09.647Z","updated":"2022-05-17T09:42:53.551Z","comments":true,"path":"2022/06/17/4.Zookeeper - 假死脑裂/","link":"","permalink":"http://example.com/2022/06/17/4.Zookeeper%20-%20%E5%81%87%E6%AD%BB%E8%84%91%E8%A3%82/","excerpt":"","text":"该问题就是服务集群因为网络震荡导致的多主多从问题，解决方案就是设置服务切换的超时时间，但也同时会导致无法达到高可用的要求。 注：该问题没什么卵用，就是为了告诉大家有 “假死脑裂” 这个词，避免面试时尴尬 ╮(￣▽￣)╭","categories":[],"tags":[]},{"title":"","slug":"3.消息队列 - 死信、延迟、重试队列","date":"2022-06-17T02:57:09.644Z","updated":"2022-05-17T09:41:02.416Z","comments":true,"path":"2022/06/17/3.消息队列 - 死信、延迟、重试队列/","link":"","permalink":"http://example.com/2022/06/17/3.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%20-%20%E6%AD%BB%E4%BF%A1%E3%80%81%E5%BB%B6%E8%BF%9F%E3%80%81%E9%87%8D%E8%AF%95%E9%98%9F%E5%88%97/","excerpt":"","text":"死信队列DLQ(Deal Letter Queue)，死信队列。当一个消息在队列中变成死信之后，他能被重新发送到 DLQ 中，与 DLQ 绑定到队列就是死信队列。 什么情况下需要死信队列 消息被拒绝 消息过期 队列达到最大长度 生产者生产一条消息，存储到普通队列中；设置队列的过期时间为 10 秒，在 10 秒内没有消费者消费消息，那么判定消息过期；此时如果设置了死信队列，过期消息被丢给死信队列交换机，然后被存储在死信队列中。 延迟队列顾名思义就是延迟执行消息，比如我们可以增加一个队列并设置其超时时间为 10 秒并且不设置任何消费者，等到消息超时，我们可以将消息放入死信队列，让消费者监听这个死信队列就达到了延迟队列的效果。 重试队列重试的消息在延迟的某个时间点（业务可设置）后，再次投递给消费者。而如果一直这样重复消费都持续失败到一定次数，就会投递到死信队列，最后需要进行人工干预。","categories":[],"tags":[]},{"title":"Java 基础 - JDK8 新特性","slug":"1.Java 基础 - JDK8 新特性","date":"2022-06-17T02:57:09.641Z","updated":"2022-06-17T07:00:29.684Z","comments":true,"path":"2022/06/17/1.Java 基础 - JDK8 新特性/","link":"","permalink":"http://example.com/2022/06/17/1.Java%20%E5%9F%BA%E7%A1%80%20-%20JDK8%20%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"概述以下列出两点重要特性： Lambda表达式（匿名函数） Stream多线程并行数据处理（重要）新特性 接口的默认方法只需要使用default关键字即可，这个特性又叫扩展方法 Lambda表达式 Functional接口函数式接口是指仅仅只包含一个抽象方法的接口，每一个该类型的Lambda表达式都会被匹配到这个抽象方法。你只需要给你的接口添加@FunctionalInterface注解。 使用::双冒号关键字来传递方法（静态方法和非静态方法） Predicate接口和Lambda表达式 Function接口 Function有一个参数并且返回一个结果，并附带了一些可以和其他函数组合的默认方法。 compose方法表示在某个方法之前执行 andThen方法表示在某个方法之后执行 注意：compose和andThen方法调用之后都会把对象自己本身返回，这可以 方便链式编程 Supplier接口，返回一个任意泛型的值，和Function接口不同的是该接口 没有任何参数 Consumer接口，接收一个任意泛型的值，和Function接口不同的是该接口 没有任何值 Optional类 Optional不是接口而是一个类，这是个用来防止NullPointerException异常的辅助类型 Optional被定义为一个简单的容器，其值可能是null或者不是null 在Java8之前一般某个函数应该返回非空对象但是偶尔却可能返回了null，而在Java8中不推荐你返回 null 而是返回Optional。 这是一个可以为 null 的容器对象。 如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。小栗子1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283package com.funtl.jdk8.feature.lambda;import java.util.Arrays;import java.util.List;import java.util.stream.Collectors;/** * Lambda 基本用法 * &lt;p&gt;Title: BaseLambda&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * @author Lusifer * @version 1.0.0 * @date 2019/1/6 10:42 */public class BaseLambda &#123; public static void main(String[] args) &#123; testForeach(); testStreamDuplicates(); &#125; /** * Lambda 遍历 */ public static void testForeach() &#123; // 定义一个数组 String[] array = &#123; &quot;尼尔机械纪元&quot;, &quot;关于我转生成为史莱姆这件事&quot;, &quot;实力至上主义教师&quot;, &quot;地狱少女&quot; &#125;; // 转换成集合 List&lt;String&gt; acgs = Arrays.asList(array); // 传统的遍历方式 System.out.println(&quot;传统的遍历方式：&quot;); for (String acg : acgs) &#123; System.out.println(acg); &#125; System.out.println(); // 使用 Lambda 表达式以及函数操作(functional operation) System.out.println(&quot;Lambda 表达式以及函数操作：&quot;); acgs.forEach((acg) -&gt; System.out.println(acg)); System.out.println(); // 在 Java 8 中使用双冒号操作符(double colon operator) System.out.println(&quot;使用双冒号操作符：&quot;); acgs.forEach(System.out::println); System.out.println(); &#125; /** * Stream 去重复 * String 和 Integer 可以使用该方法去重 */ public static void testStreamDuplicates() &#123; System.out.println(&quot;Stream 去重复：&quot;); // 定义一个数组 String[] array = &#123; &quot;尼尔机械纪元&quot;, &quot;尼尔机械纪元&quot;, &quot;关于我转生成为史莱姆这件事&quot;, &quot;关于我转生成为史莱姆这件事&quot;, &quot;实力至上主义教师&quot;, &quot;实力至上主义教师&quot;, &quot;地狱少女&quot;, &quot;地狱少女&quot; &#125;; // 转换成集合 List&lt;String&gt; acgs = Arrays.asList(array); // Stream 去重复 acgs = acgs.stream().distinct().collect(Collectors.toList()); // 打印 acgs.forEach(System.out::println); &#125;&#125;","categories":[],"tags":[]},{"title":"","slug":"10.Java 基础 - 抽象类和接口有什么区别","date":"2022-06-17T02:57:09.639Z","updated":"2022-05-18T08:49:37.330Z","comments":true,"path":"2022/06/17/10.Java 基础 - 抽象类和接口有什么区别/","link":"","permalink":"http://example.com/2022/06/17/10.Java%20%E5%9F%BA%E7%A1%80%20-%20%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"参数 抽象类 接口 默认的方法实现 它可以有默认的方法实现 接口完全是抽象的。它根本不存在方法的实现 实现 子类使用 extends 关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 子类使用关键字 implements 来实现接口。它需要提供接口中所有声明的方法的实现 构造器 抽象类可以有构造器 接口不能有构造器 与正常 Java 类的区别 除了你不能实例化抽象类之外，它和普通Java类没有任何区别 接口是完全不同的类型 访问修饰符 抽象方法可以有 public、protected 和 default 这些修饰符 接口方法默认修饰符是 public。你不可以使用其它修饰符。 main 方法 抽象方法可以有 main 方法并且我们可以运行它 接口没有 main 方法，因此我们不能运行它。 多继承 抽象方法可以继承一个类和实现多个接口 接口只可以继承一个或多个其它接口 速度 它比接口速度要快 接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。 添加新方法 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 如果你往接口中添加方法，那么你必须改变实现该接口的类。","categories":[],"tags":[]},{"title":"","slug":"9.Java 基础 - 重载和重写的区别","date":"2022-06-17T02:57:09.637Z","updated":"2022-05-18T08:48:49.913Z","comments":true,"path":"2022/06/17/9.Java 基础 - 重载和重写的区别/","link":"","permalink":"http://example.com/2022/06/17/9.Java%20%E5%9F%BA%E7%A1%80%20-%20%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E7%9A%84%E5%8C%BA%E5%88%AB/","excerpt":"","text":"重载 Overload表示同一个类中可以有多个名称相同的方法，但这些方法的参数列表各不相同（即参数个数或类型不同）。 重写 Override表示子类中的方法可以与父类中的某个方法的名称和参数完全相同，通过子类创建的实例对象调用这个方法时，将调用子类中的定义方法，这相当于把父类中定义的那个完全相同的方法给覆盖了，这也是面向对象编程的多态性的一种表现。子类覆盖父类的方法时，只能比父类抛出更少的异常，或者是抛出父类抛出的异常的子异常，因为子类可以解决父类的一些问题，不能比父类有更多的问题。子类方法的访问权限只能比父类的更大，不能更小。如果父类的方法是private类型，那么，子类则不存在覆盖的限制，相当于子类中增加了一个全新的方法","categories":[],"tags":[]},{"title":"","slug":"8.Java 基础 - int 和 Integer 有什么区别","date":"2022-06-17T02:57:09.635Z","updated":"2022-05-18T08:41:16.898Z","comments":true,"path":"2022/06/17/8.Java 基础 - int 和 Integer 有什么区别/","link":"","permalink":"http://example.com/2022/06/17/8.Java%20%E5%9F%BA%E7%A1%80%20-%20int%20%E5%92%8C%20Integer%20%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/","excerpt":"","text":"int 是 Java 提供的 8 种原始数据类型之一。Java 为每个原始类型提供了封装类，Integer 是 Java 为 int 提供的封装类。 int 的默认值为 0，而 Integer 的默认值为 null，是引用类型，即 Integer 可以区分出未赋值和值为 0 的区别，int 则无法表达出未赋值的情况， Java 中 int 和 Integer 关系是比较微妙的。关系如下： int 是基本的数据类型； Integer 是 int 的封装类； int 和 Integer 都可以表示某一个数值； int 和 Integer 不能够互用，因为他们两种不同的数据类型；","categories":[],"tags":[]},{"title":"","slug":"7.Java 基础 - final, finally, finalize","date":"2022-06-17T02:57:09.633Z","updated":"2022-05-18T08:38:00.008Z","comments":true,"path":"2022/06/17/7.Java 基础 - final, finally, finalize/","link":"","permalink":"http://example.com/2022/06/17/7.Java%20%E5%9F%BA%E7%A1%80%20-%20final,%20finally,%20finalize/","excerpt":"","text":"final用于声明属性,方法和类, 分别表示属性不可变, 方法不可覆盖, 类不可继承. finally是异常处理语句结构的一部分，表示总是执行. finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等. JVM不保证此方法总被调用.","categories":[],"tags":[]},{"title":"","slug":"6.Java 基础 - 面向对象的特征","date":"2022-06-17T02:57:09.631Z","updated":"2022-05-18T08:32:08.504Z","comments":true,"path":"2022/06/17/6.Java 基础 - 面向对象的特征/","link":"","permalink":"http://example.com/2022/06/17/6.Java%20%E5%9F%BA%E7%A1%80%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%89%B9%E5%BE%81/","excerpt":"","text":"概述面向对象的三个基本特征是：封装、继承、多态。 封装封装最好理解了。封装是面向对象的特征之一，是对象和类概念的主要特性。封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。 继承面向对象编程 (OOP) 语言的一个主要功能就是“继承”。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 多态多态性（polymorphisn）是允许你将父对象设置成为和一个或更多的他的子对象相等的技术，赋值之后，父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。简单的说，就是一句话：允许将子类类型的指针赋值给父类类型的指针。 实现多态，有二种方式，覆盖，重载。","categories":[],"tags":[]},{"title":"双亲委派模型","slug":"2.Java 基础 - 双亲委派模型","date":"2022-06-02T02:05:36.000Z","updated":"2022-06-17T07:00:27.779Z","comments":true,"path":"2022/06/02/2.Java 基础 - 双亲委派模型/","link":"","permalink":"http://example.com/2022/06/02/2.Java%20%E5%9F%BA%E7%A1%80%20-%20%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"类加载器加载类的开放性类加载器（ClassLoader) 是Java语言的一项创新，也是Java语言流行的一个重要原因，在类加载的第一阶段“加载”过程中需要通过一个类的全限定名来回去定义此类的二进制字节流，完成这个动作的代码块就是 类加载器，这一动作是放在Java虚拟机外部去实现的，以便让应用程序自己去决定如何获取所需的类。 虚拟机规范并没有指明二进制字节流要从一个Class文件获取，或者说根本没有指明从哪里获取、怎样获取。这种开放使得Java在很多领域得到充分运用，例如： 从ZIP包中读取，这很常见，成为JAR,EAR,WAR格式的基础 从网络中获取，最典型的运用就是Applet 运用时计算生成，最典型的是动态代理技术，在java.lang.reflect.Proxy中，就是用了ProxyGrenerator.generateProxyClass 来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流 有其它文件生成，最典型的JSP应用，由JSP文件生成对应的Class类 类加载器与类的唯一性类加载器虽然只用于实现类的加载动作，但是对于任意一个类，都需要由它的类加载器和这个类本身共同确立其在Java虚拟机中的唯一性。通俗的说JVM中两个类是否“相等”，首先就必须是同一个类加载器加载的，否则，即使这两个类加来源于同一个Class文件，被同一个虚拟机加载，只要类加载器不同那么这两个类必定是不相同的。 第二部分使用自定义的类加载器加载ClassLoaderTest,classcom.jvm.classloading.ClassLoaderTest显示，obj2确实是类com.jvm.classloading.ClassLoaderTest实例化出来的对象，但是第二句输出false此时虚拟机中有3个ClassLoaderTest类，由于第3个类的类加载器与前面2个类加载器不同，虽然来源于同一个Class文件，但是它是一个独立的类，所属类型检查是返回结果自然是false。 双亲委派模型类加载器种类从Java虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（BootstrapClassLoader),这种类加载器使用C++语言实现（HotSport虚拟机中），是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都有Java语言实现，独立于虚拟机外部，并且全部继承自java.lang.ClassLoader。从开发者的角度，类加载器可以细分为： 启动（Bootstrap)类加载器：负责将java_Home&#x2F;lib下面的类库加载到内存中（比如rt.jar)。由于引导类加载器涉及到虚拟机本地实现细节开发者无法直接获取到启动类的加载器的引用，所以不允许直接通过应用进行操作。 标准扩展（Extension)类加载器：是由Sun的**ExtClassLoader(sun.misc.Launcher$ExtClassLoader)**实现的。它负责将java_home&#x2F;lib&#x2F;ext或者由系统变量Java.ext.dir指定位置中的类库加载到内存中。开发者可以直接使用标准扩展类加载器。 应用程序（Application)类加载器：是由Sun的AppClassLoader(sun.misc.Launcher$AppClassLoader) 实现的。它负责将系统类路径（CLASSPATH)中指定的类库加载到内存中。开发者可以直接使用系统类加载器。由于这个类加载器是ClassLoader中getSystemClassLoader()方法的返回值，因此一般称为（System）加载器。除此之外， 还有自定义的类加载器，他们之间的层次关系被称为类加载器的双亲委派模型。该模型要求除了顶层的启动类加载器外，其他的类加载器都应该有自己的父类加载器，而这种父子关系一般通过组合（Composition）关系；来实现，而不是通过继承（Inheritance)。 双亲委派模型双亲委派模型过程某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父类加载器，依次递归，如果父类加载器可以完成加载任务，就成功返回；只有父类加载器无法完成此加载任务时，才自己去加载。使用双亲委派模型的好处在于Java类随着他的类加载器一起具备了一种带有优先级的层次关系 。例如类java.lang.Object ,它存在在rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的Bootstrap ClassLoader 进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有双亲委派模型而是由各个类加载器自行加载的话，如果用户编写了一个java.lang.Object 的同名并放在ClassPath中，那系统中将会出现很多个不同的Object类，程序将混乱。因此，如果开发者尝试编写一个与rt.jar类库中重名的Java类，可以正常编译，但是永远无法被加载运动 双亲委派模型的系统实现在java.lang.ClassLoader 的loadClass() 方法中，先检查是否已经被加载过，若没有加载则调用父类加载器的loadClass()方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父加载失败，则抛出ClassNotFounction 异常后，再调用自己的findClass() 方法进行加载。 12345678910111213141516171819202122protected synchronized Class&lt;?&gt; loadClass(String name,boolean resolve)throws ClassNotFoundException&#123; //check the class has been loaded or not Class c = findLoadedClass(name); if(c == null)&#123; try&#123; if(parent != null)&#123; c = parent.loadClass(name,false); &#125;else&#123; c = findBootstrapClassOrNull(name); &#125; &#125;catch(ClassNotFoundException e)&#123; //if throws the exception ,the father can not complete the load &#125; if(c == null)&#123; c = findClass(name); &#125; &#125; if(resolve)&#123; resolveClass(c); &#125; return c;&#125; 注意，双亲委派模型是 Java 设计者推荐给开发者的类加载器的实现方式，并不是强制规定的。大多数的类加载器都遵循这个模型，但是 JDK 中也有较大规模破坏双亲模型的情况，例如线程上下文类加载器（Thread Context ClassLoader）的出现","categories":[],"tags":[]},{"title":"第一篇Hexo blog文章","slug":"第一篇Hexo-blog文章","date":"2022-06-02T02:05:36.000Z","updated":"2022-06-02T02:05:36.046Z","comments":true,"path":"2022/06/02/第一篇Hexo-blog文章/","link":"","permalink":"http://example.com/2022/06/02/%E7%AC%AC%E4%B8%80%E7%AF%87Hexo-blog%E6%96%87%E7%AB%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-06-02T01:59:15.706Z","updated":"2022-06-02T01:59:15.706Z","comments":true,"path":"2022/06/02/hello-world/","link":"","permalink":"http://example.com/2022/06/02/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}